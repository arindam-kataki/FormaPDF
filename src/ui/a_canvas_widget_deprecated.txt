import time

from PyQt6.QtWidgets import QWidget
from PyQt6.QtCore import Qt, QTimer, QRectF, pyqtSignal, pyqtSlot
from PyQt6.QtGui import QPainter, QPixmap, QPen, QBrush
from typing import Optional, List, Tuple, Set


class CanvasWidget(QWidget):
    """Canvas widget for rendering PDF pages - fixed paint loop issue"""

    # Signals
    pageChanged = pyqtSignal(int)  # Emitted when current page changes
    zoomChanged = pyqtSignal(float)  # Emitted when zoom level changes
    mousePositionChanged = pyqtSignal(int, float, float)  # page, doc_x, doc_y

    def __init__(self, parent=None):
        """Initialize Canvas Widget with all optimizations and features"""
        super().__init__(parent)

        # ========================================
        # CORE COMPONENTS
        # ========================================
        self.document = None
        self.layout_manager = None
        self.zoom_level = 1.0
        self.current_page = 0

        # ========================================
        # RENDERING STATE
        # ========================================
        self.rendered_pages = {}  # Cache for rendered page pixmaps
        self.visible_pages = []  # Currently visible page indices
        self.viewport_rect = QRectF()

        # ========================================
        # PERFORMANCE OPTIMIZATION
        # ========================================
        # Render timer for debouncing
        self.render_timer = QTimer()
        self.render_timer.timeout.connect(self._perform_render_smart)
        self.render_timer.setSingleShot(True)
        self.needs_render = False

        # Paint loop prevention
        self.is_painting = False
        self.paint_count = 0
        self._last_paint_time = 0.0

        # ========================================
        # SMART SCROLL OPTIMIZATION
        # ========================================

        self.smart_scroll_optimizer = SmartScrollOptimizer(self)
        self._pages_needing_repaint = set()  # Track which pages need actual repainting
        self._pages_to_render = set()  # Pages scheduled for rendering

        # ========================================
        # LINK COUNTING OPTIMIZATION
        # ========================================
        # Cache for link counts to avoid repeated extraction

        self._cache_max_age = 30.0  # Cache valid for 30 seconds
        self._link_cache_timestamps = {}

        # Rapid paint detection for link counting
        self._last_link_paint_time = 0.0
        self._paint_count_in_window = 0
        self._paint_window_start = 0.0

        # ========================================
        # PAGE INFO OVERLAY SETTINGS
        # ========================================
        self._show_page_info_overlay = True  # Toggle for page info overlay
        self._overlay_font_size = 9
        self._overlay_width = 200
        self._overlay_height = 55

        # ========================================
        # UI SETTINGS AND STYLING
        # ========================================
        self.setMinimumSize(400, 300)
        self.setMouseTracking(True)

        # Background styling
        self.setStyleSheet("background-color: #2b2b2b;")

        # ========================================
        # MOUSE AND INTERACTION STATE
        # ========================================
        self._mouse_pressed = False
        self._last_mouse_position = None
        self._drag_start_position = None

        # ========================================
        # CACHE MANAGEMENT
        # ========================================
        self._cache_cleanup_timer = QTimer()
        self._cache_cleanup_timer.timeout.connect(self._periodic_cache_cleanup)
        self._cache_cleanup_timer.start(10000)  # Cleanup every 10 seconds

        # Cache size limits
        self._max_cached_pages = 10  # Maximum pages to keep in cache
        self._cache_adjacent_pages = 2  # Number of adjacent pages to cache

        # ========================================
        # SIGNALS FOR INTEGRATION
        # ========================================
        # These signals are defined in the class but connected here for clarity
        # self.pageChanged = pyqtSignal(int)     # Emitted when current page changes
        # self.zoomChanged = pyqtSignal(float)   # Emitted when zoom level changes
        # self.mousePositionChanged = pyqtSignal(int, float, float)  # page, doc_x, doc_y

        # ========================================
        # SCROLL DETECTION
        # ========================================
        self._last_scroll_time = 0.0
        self._scroll_velocity = 0.0
        self._is_actively_scrolling = False

        # ========================================
        # RENDER QUALITY SETTINGS
        # ========================================
        self._render_dpi_base = 72  # Base DPI for rendering
        self._render_quality_high = True  # High quality rendering flag
        self._antialiasing_enabled = True

        # ========================================
        # INITIALIZATION COMPLETION
        # ========================================
        print("üé® Canvas widget initialized with full optimization suite:")
        print("   ‚úÖ Smart scroll optimization")
        print("   ‚úÖ Link counting cache")
        print("   ‚úÖ Paint loop prevention")
        print("   ‚úÖ Performance monitoring")
        print("   ‚úÖ Intelligent cache management")
        print("   ‚úÖ Page info overlay system")

    def _periodic_cache_cleanup(self):
        """Periodic cache cleanup to prevent memory bloat"""
        try:
            if not hasattr(self, 'rendered_pages'):
                return

            initial_cache_size = len(self.rendered_pages)

            if initial_cache_size > self._max_cached_pages:
                # Keep only the most recently used pages
                pages_to_keep = set(self.visible_pages)

                # Add adjacent pages
                for page_idx in self.visible_pages:
                    for offset in range(-self._cache_adjacent_pages, self._cache_adjacent_pages + 1):
                        adjacent_page = page_idx + offset
                        if adjacent_page >= 0:  # Will check upper bound when we have document
                            pages_to_keep.add(adjacent_page)

                # Remove excess pages
                pages_to_remove = []
                for page_idx in self.rendered_pages.keys():
                    if page_idx not in pages_to_keep:
                        pages_to_remove.append(page_idx)

                # Remove oldest pages first (simple LRU)
                pages_to_remove.sort()
                excess_count = initial_cache_size - self._max_cached_pages
                for page_idx in pages_to_remove[:excess_count]:
                    del self.rendered_pages[page_idx]

                if pages_to_remove:
                    print(f"üßπ Periodic cache cleanup: Removed {len(pages_to_remove[:excess_count])} pages")

        except Exception as e:
            print(f"‚ùå Cache cleanup error: {e}")

    @pyqtSlot(object)
    def on_document_loaded(self, document):
        """Handle document loaded signal from main window"""
        print(f"üìÑ Canvas: Document loaded with {document.get_page_count()} pages")
        self._load_document(document)

    @pyqtSlot()
    def on_document_closed(self):
        """Handle document closed signal from main window"""
        print("‚ùå Canvas: Document closed")
        self._clear_document()

    def _load_document(self, document):
        """Internal method to load document into canvas"""
        print("üîÑ Loading document into canvas...")
        self.document = document

        if document:
            try:
                from a_layout_manager import LayoutManager
                print("üìê Creating layout manager...")
                self.layout_manager = LayoutManager(document, self.zoom_level)

                # Get canvas size info
                width, height = self.layout_manager.get_canvas_size()
                print(f"üìè Canvas size calculated: {width}x{height}")

                self._update_canvas_size()
                self.current_page = 0
                self.pageChanged.emit(0)
                self._document_loaded = True

                # Set initial visible pages - simplified
                print("üîç Setting initial visible pages...")
                visible_pages = [0]  # Start with just first page
                if self.document.get_page_count() > 1:
                    visible_pages.append(1)

                print(f"üëÅÔ∏è Initial visible pages: {visible_pages}")
                self.visible_pages = visible_pages
                self.schedule_render()

                print("‚úÖ Document loaded successfully into canvas")
            except Exception as e:
                print(f"‚ùå Error loading document into canvas: {e}")
                import traceback
                traceback.print_exc()
        else:
            self._clear_document()

    def _clear_document(self):
        """Internal method to clear document from canvas"""
        print("üßπ Clearing document from canvas...")
        self.document = None
        self.layout_manager = None
        self.rendered_pages.clear()
        self.visible_pages.clear()
        self.current_page = 0
        self._document_loaded = False
        self.update()

    def set_zoom(self, zoom_level: float, maintain_position: bool = True, goto_current_page: bool = False,
                 goto_page_top_with_margin: bool = False):
        """
        Set zoom level with position control

        Args:
            zoom_level: New zoom level (0.1 to 5.0)
            maintain_position: If True, maintain current scroll position proportionally
            goto_current_page: If True, scroll to current page top after zoom (for fit operations)
            goto_page_top_with_margin: If True, go to page top with proper inter-page margin
        """
        zoom_level = max(0.1, min(5.0, zoom_level))

        if abs(self.zoom_level - zoom_level) > 0.01:
            print(
                f"üîç Setting zoom to {zoom_level:.2f}, maintain_position={maintain_position}, goto_current_page={goto_current_page}, goto_page_top_with_margin={goto_page_top_with_margin}")

            # STEP 1: Stop timer to prevent conflicts
            self.render_timer.stop()
            self.needs_render = False

            # STEP 2: Capture current state (only if maintaining position)
            scroll_area = self._get_scroll_area()
            x_ratio, y_ratio = 0, 0
            viewport_width, viewport_height = 0, 0

            if maintain_position and not goto_current_page and not goto_page_top_with_margin and scroll_area and self.layout_manager:
                # Current canvas dimensions
                old_canvas_width, old_canvas_height = self.layout_manager.get_canvas_size()

                # Current scroll position
                current_scroll_x = scroll_area.horizontalScrollBar().value()
                current_scroll_y = scroll_area.verticalScrollBar().value()

                # Current viewport size
                viewport_width = scroll_area.viewport().width()
                viewport_height = scroll_area.viewport().height()

                # Calculate proportional position within canvas
                x_ratio = current_scroll_x / max(old_canvas_width, viewport_width) if old_canvas_width > 0 else 0
                y_ratio = current_scroll_y / max(old_canvas_height, viewport_height) if old_canvas_height > 0 else 0

                print(f"üìê Saving position ratios: x={x_ratio:.3f}, y={y_ratio:.3f}")

            # STEP 3: Update zoom level and layout
            self.zoom_level = zoom_level

            if self.layout_manager:
                self.layout_manager.set_zoom(zoom_level)
                self._update_canvas_size()

            # STEP 4: Apply position strategy
            if scroll_area and self.layout_manager:
                if goto_page_top_with_margin:
                    # Show page at top of display area WITH the inter-page gap visible
                    current_page = getattr(self, 'current_page', 0)

                    if current_page == 0:
                        # For first page, scroll to absolute top (Y=0) to show the top margin + page
                        scroll_y = 0
                        print(f"üìê Fit page: First page - scrolling to absolute top (0)")
                    else:
                        # For other pages, get the page position and show gap above it
                        page_y = self.layout_manager.get_page_y_position(current_page)
                        inter_page_margin = getattr(self.layout_manager, 'PAGE_SPACING_VERTICAL', 15)
                        scroll_y = max(0, page_y - inter_page_margin)
                        print(
                            f"üìê Fit page: Page {current_page} - page_y={page_y}, gap={inter_page_margin}, scroll_to={scroll_y}")

                    scroll_area.horizontalScrollBar().setValue(0)  # Reset horizontal
                    scroll_area.verticalScrollBar().setValue(int(scroll_y))

                elif goto_current_page:
                    # Go to current page top (original behavior)
                    current_page = getattr(self, 'current_page', 0)
                    page_y = self.layout_manager.get_page_y_position(current_page)

                    print(f"üìê Going to current page {current_page} at y={page_y}")
                    scroll_area.horizontalScrollBar().setValue(0)  # Reset horizontal
                    scroll_area.verticalScrollBar().setValue(int(page_y))

                elif maintain_position:
                    # Maintain proportional position
                    new_canvas_width, new_canvas_height = self.layout_manager.get_canvas_size()

                    # Apply same ratios to new canvas size
                    effective_canvas_width = max(new_canvas_width, viewport_width)
                    effective_canvas_height = max(new_canvas_height, viewport_height)

                    new_scroll_x = x_ratio * effective_canvas_width
                    new_scroll_y = y_ratio * effective_canvas_height

                    # Clamp to valid scroll range
                    max_scroll_x = max(0, new_canvas_width - viewport_width)
                    max_scroll_y = max(0, new_canvas_height - viewport_height)

                    new_scroll_x = max(0, min(new_scroll_x, max_scroll_x))
                    new_scroll_y = max(0, min(new_scroll_y, max_scroll_y))

                    print(f"üìê Maintaining position: scroll=({new_scroll_x:.1f},{new_scroll_y:.1f})")

                    # Apply new scroll position
                    scroll_area.horizontalScrollBar().setValue(int(new_scroll_x))
                    scroll_area.verticalScrollBar().setValue(int(new_scroll_y))

                # If neither maintain_position nor goto_current_page nor goto_page_top_with_margin, keep current scroll values

            # STEP 5: Clear old cache and recalculate visible pages
            self.rendered_pages.clear()

            # Recalculate what's visible at new zoom and scroll position
            if scroll_area and self.layout_manager:
                final_scroll_x = scroll_area.horizontalScrollBar().value()
                final_scroll_y = scroll_area.verticalScrollBar().value()

                viewport_rect = QRectF(
                    final_scroll_x,
                    final_scroll_y,
                    scroll_area.viewport().width(),
                    scroll_area.viewport().height()
                )

                visible_pages = self.layout_manager.get_visible_pages(viewport_rect)
                self.visible_pages = visible_pages
                print(f"üîç Visible pages after zoom: {visible_pages}")

            # STEP 6: Render visible pages at new zoom
            if self.visible_pages and not self.is_painting:
                for page_index in self.visible_pages:
                    if 0 <= page_index < self.document.get_page_count():
                        print(f"üñºÔ∏è Rendering page {page_index} for zoom change...")
                        self._render_page(page_index)

            print("‚úÖ Zoom complete")
            self.zoomChanged.emit(zoom_level)


    def _get_scroll_area(self):
        """Get the scroll area containing this canvas"""
        parent = self.parent()
        while parent:
            if hasattr(parent, 'verticalScrollBar') and hasattr(parent, 'viewport'):
                return parent
            parent = parent.parent()
        return None

    def get_zoom(self) -> float:
        """Get current zoom level"""
        return self.zoom_level

    def get_zoom_percent(self) -> int:
        """Get zoom as percentage"""
        return int(self.zoom_level * 100)

    def zoom_in(self, factor: float = 1.25):
        """Zoom in by factor"""
        self.set_zoom(self.zoom_level * factor)

    def zoom_out(self, factor: float = 1.25):
        """Zoom out by factor"""
        self.set_zoom(self.zoom_level / factor)

    def fit_to_width(self, available_width: int):
        """Fit page to available width"""
        if not self.document:
            return

        page_size = self.document.get_page_size(0)
        zoom = (available_width - 40) / page_size.width()  # 40px margin
        self.set_zoom(zoom)

    def fit_to_page(self, available_width: int, available_height: int):
        """Simpler fit to page - use first visible page"""
        if not self.document or not self.layout_manager:
            return

        # Get currently visible pages
        scroll_area = self._get_scroll_area()
        if scroll_area:
            viewport_top = scroll_area.verticalScrollBar().value()
            viewport_height = scroll_area.viewport().height()
            viewport_rect = QRectF(0, viewport_top, scroll_area.viewport().width(), viewport_height)

            visible_pages = self.layout_manager.get_visible_pages(viewport_rect)
            if visible_pages:
                target_page = visible_pages[0]  # Use first visible page
                print(f"üìÑ Fit to page: Using first visible page {target_page}")
            else:
                target_page = self.current_page
                print(f"üìÑ Fit to page: No visible pages, using current {target_page}")
        else:
            target_page = self.current_page

        # Calculate zoom based on target page
        page_size = self.document.get_page_size(target_page)
        zoom_w = (available_width - 40) / page_size.width()
        zoom_h = (available_height - 40) / page_size.height()
        zoom = min(zoom_w, zoom_h)

        # Update current page and apply zoom
        self.current_page = target_page
        self.set_zoom(zoom, maintain_position=False, goto_page_top_with_margin=True)

    def set_visible_pages(self, page_indices: List[int], viewport_rect: QRectF):
        """Set which pages are currently visible"""
        if self.is_painting:
            return

        print(f"üëÅÔ∏è Setting visible pages: {page_indices}")
        self.visible_pages = page_indices
        self.viewport_rect = viewport_rect
        self.schedule_render()

        # ‚úÖ ONLY update current page if it's genuinely not visible
        # Don't automatically jump to first visible page during zoom
        if page_indices and self.current_page not in page_indices:
            # Only change if current page is far from visible range
            if not any(abs(self.current_page - p) <= 1 for p in page_indices):
                new_page = page_indices[0]
                if new_page != self.current_page:
                    self.current_page = new_page
                    self.pageChanged.emit(new_page)

    def get_page_at_position(self, y_position: float) -> int:
        """Get page index at Y position"""
        if self.layout_manager:
            return self.layout_manager.get_page_at_position(y_position)
        return 0

    def get_page_y_position(self, page_index: int) -> float:
        """Get Y position of page start"""
        if self.layout_manager:
            return self.layout_manager.get_page_y_position(page_index)
        return 0.0

    def get_current_page_from_scroll(self, scroll_y: float) -> int:
        """Get current page based on scroll position"""
        return self.get_page_at_position(scroll_y + 100)  # Add offset for better detection

    def get_visible_pages_in_viewport(self, viewport_rect: QRectF) -> List[int]:
        """Get list of page indices visible in viewport"""
        if self.layout_manager:
            visible = self.layout_manager.get_visible_pages(viewport_rect)
            print(f"üîç Visible pages in viewport {viewport_rect}: {visible}")
            return visible
        return []

    def get_canvas_size(self) -> tuple:
        """Get total canvas size needed"""
        if self.layout_manager:
            size = self.layout_manager.get_canvas_size()
            print(f"üìè Canvas size: {size}")
            return size
        return (400, 300)

    def document_to_canvas_coordinates(self, page_index: int, doc_x: float, doc_y: float) -> tuple:
        """Convert document coordinates to canvas coordinates"""
        if self.layout_manager:
            from PyQt6.QtCore import QPointF
            doc_point = QPointF(doc_x, doc_y)
            canvas_point = self.layout_manager.document_to_canvas(page_index, doc_point)
            return (canvas_point.x(), canvas_point.y())
        return (0, 0)

    def canvas_to_document_coordinates(self, page_index: int, canvas_x: float, canvas_y: float) -> tuple:
        """Convert canvas coordinates to document coordinates"""
        if self.layout_manager:
            from PyQt6.QtCore import QPointF
            canvas_point = QPointF(canvas_x, canvas_y)
            doc_point = self.layout_manager.canvas_to_document(page_index, canvas_point)
            return (doc_point.x(), doc_point.y())
        return (0, 0)

    def get_page_at_canvas_position(self, canvas_x: float, canvas_y: float) -> Optional[int]:
        """Get page index at canvas position"""
        if not self.layout_manager:
            return None

        for i in range(self.document.get_page_count() if self.document else 0):
            page_rect = self.layout_manager.get_page_rect(i)
            if page_rect and page_rect.contains(canvas_x, canvas_y):
                return i
        return None

    def _render_page(self, page_index: int):
        """Render a single page"""
        try:
            print(f"üñºÔ∏è Rendering page {page_index} at zoom {self.zoom_level:.2f}")

            # CRITICAL FIX: Use consistent DPI calculation
            # Calculate render DPI based on zoom to match layout manager expectations
            base_dpi = 72  # PDF native DPI
            render_dpi = int(base_dpi * self.zoom_level)

            print(f"üìê Using render DPI: {render_dpi} (zoom: {self.zoom_level:.2f})")

            pixmap = self.document.render_page(page_index, 1.0, render_dpi)  # Use zoom=1.0, control via DPI
            print(f"‚úÖ Page {page_index} rendered: {pixmap.width()}x{pixmap.height()}")

            self.rendered_pages[page_index] = pixmap
        except Exception as e:
            print(f"‚ùå Error rendering page {page_index}: {e}")
            import traceback
            traceback.print_exc()

    def _update_canvas_size(self):
        """Update canvas size based on layout"""
        if self.layout_manager:
            width, height = self.layout_manager.get_canvas_size()
            print(f"üìè Updating canvas size to: {width}x{height}")
            self.resize(max(width, 400), max(height, 300))
            print(f"üìè Canvas widget size: {self.size()}")

    # Add to paintEvent() method for debugging
    def paintEvent(self, event):
        """Paint the visible pages - with loop prevention and debugging"""

        # Debug: What triggered this paint event?
        import traceback
        stack = traceback.extract_stack()
        recent_calls = [frame.name for frame in stack[-5:]]
        print(f"üé® Paint event #{self.paint_count + 1} triggered by: {' -> '.join(recent_calls)}")

        # CRITICAL: Prevent infinite paint loops
        if self.is_painting:
            print("üîÑ Paint event blocked - already painting")
            return

        self.is_painting = True
        self.paint_count += 1

        print(f"üé® Paint event #{self.paint_count}. Visible pages: {self.visible_pages}")

        try:
            painter = QPainter(self)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)

            # Paint background
            painter.fillRect(self.rect(), QBrush(Qt.GlobalColor.darkGray))

            if not self.document or not self.layout_manager:
                self._paint_no_document(painter)
                return

            # Paint visible pages
            pages_painted = 0
            for page_index in self.visible_pages:
                if self._paint_page(painter, page_index):
                    pages_painted += 1

            print(f"üé® Paint complete. Pages painted: {pages_painted}")

        finally:
            # ALWAYS reset painting flag
            self.is_painting = False

    def _paint_no_document(self, painter):
        """Paint message when no document is loaded"""
        painter.setPen(QPen(Qt.GlobalColor.white))
        painter.drawText(self.rect(), Qt.AlignmentFlag.AlignCenter, "No document loaded")
        print("üé® Painted 'no document' message")

    def _paint_page(self, painter, page_index: int) -> bool:
        """Paint a single page - returns True if painted"""
        page_rect = self.layout_manager.get_page_rect(page_index)
        if not page_rect:
            print(f"‚ùå No page rect for page {page_index}")
            return False

        print(f"üé® Painting page {page_index} at rect {page_rect}")

        # Draw page background
        painter.fillRect(page_rect, QBrush(Qt.GlobalColor.white))

        # Draw page border
        painter.setPen(QPen(Qt.GlobalColor.black, 1))
        painter.drawRect(page_rect)

        # Draw rendered content if available
        if page_index in self.rendered_pages:
            pixmap = self.rendered_pages[page_index]
            print(f"üñºÔ∏è Drawing pixmap for page {page_index}: {pixmap.width()}x{pixmap.height()}")

            # FIXED: Scale pixmap to fit page rect exactly
            painter.drawPixmap(page_rect.toRect(), pixmap)
            print(f"‚úÖ Pixmap scaled and drawn for page {page_index}")
        else:
            # Draw loading indicator
            painter.setPen(QPen(Qt.GlobalColor.gray))
            painter.drawText(page_rect, Qt.AlignmentFlag.AlignCenter, f"Loading page {page_index + 1}...")
            print(f"‚è≥ Loading indicator drawn for page {page_index}")

        # ADD THIS: Draw page info overlay directly on the page
        #self._draw_page_info_overlay(painter, page_index, page_rect)

        return True

    def _draw_page_info_overlay(self, painter, page_index: int, page_rect):
        """Draw page info overlay at (10, 10) relative to page with timing info"""
        try:
            from PyQt6.QtGui import QColor, QBrush, QPen, QFont
            from PyQt6.QtCore import QRect

            # Calculate overlay position (10, 10) relative to page top-left
            overlay_x = int(page_rect.x() + 10)
            overlay_y = int(page_rect.y() + 10)
            overlay_width = 180  # Made wider to fit timing info
            overlay_height = 55  # Made taller for 3 lines

            # Get link count and timing
            link_count, seconds_taken = self._get_link_count_for_page(page_index)

            # Create overlay rectangle
            overlay_rect = QRect(overlay_x, overlay_y, overlay_width, overlay_height)

            # Draw semi-transparent background
            background_color = QColor(0, 0, 0, 180)
            painter.fillRect(overlay_rect, QBrush(background_color))

            # Draw border
            border_color = QColor(100, 100, 100, 255)
            painter.setPen(QPen(border_color, 1))
            painter.drawRect(overlay_rect)

            # Set up text drawing
            painter.setPen(QPen(QColor(255, 255, 255, 255)))  # White text
            painter.setFont(QFont("Arial", 9, QFont.Weight.Bold))  # Slightly smaller to fit 3 lines

            # Prepare text content
            page_text = f"Page {page_index + 1}"
            links_text = f"Links: {link_count}"
            timing_text = f"Time: {seconds_taken:.3f}s"

            # Text positioning
            text_x = overlay_x + 8
            text_y = overlay_y + 14
            line_height = 13

            # Draw all three lines
            painter.drawText(text_x, text_y, page_text)
            painter.drawText(text_x, text_y + line_height, links_text)
            painter.drawText(text_x, text_y + (line_height * 2), timing_text)

            print(f"üìä Drew page info overlay: Page {page_index + 1}, {link_count} links, {seconds_taken:.3f}s")

        except Exception as e:
            print(f"‚ùå Error drawing page info overlay: {e}")
            import traceback
            traceback.print_exc()

    # ADD THIS: Method to get link count (same as before)
    def _get_link_count_for_page(self, page_index: int) -> Tuple[int, float]:
        """
        Get the number of links on a specific page and time taken to generate the count

        Args:
            page_index: 0-based page index

        Returns:
            Tuple[int, float]: (link_count, seconds_taken)
        """
        import time

        start_time = time.time()
        link_count = 0

        try:
            # Try to get link count from link manager if available
            if hasattr(self, 'link_manager') and self.link_manager:
                page_links = self.link_manager.extract_page_links(page_index)
                link_count = len(page_links)

            # Try to get from parent's link integration
            elif hasattr(self.parent(), 'link_integration') and self.parent().link_integration:
                link_manager = self.parent().link_integration.link_manager
                if link_manager:
                    page_links = link_manager.extract_page_links(page_index)
                    link_count = len(page_links)

            # Fallback: try to access PDF document directly
            elif self.document and hasattr(self.document, 'doc'):
                if page_index < len(self.document.doc):
                    page = self.document.doc[page_index]
                    raw_links = page.get_links()
                    link_count = len(raw_links)

            # Additional fallback for pdf_canvas.py style documents
            elif hasattr(self, 'pdf_document') and self.pdf_document:
                if hasattr(self.pdf_document, 'doc'):
                    # PyMuPDF document
                    if page_index < len(self.pdf_document.doc):
                        page = self.pdf_document.doc[page_index]
                        links = page.get_links()
                        link_count = len(links)
                elif hasattr(self.pdf_document, '__getitem__'):
                    # Alternative access method
                    if page_index < self.pdf_document.page_count:
                        page = self.pdf_document[page_index]
                        links = page.get_links()
                        link_count = len(links)

        except Exception as e:
            print(f"‚ùå Error getting link count for page {page_index}: {e}")
            link_count = 0

        end_time = time.time()
        seconds_taken = end_time - start_time

        print(f"üîó Page {page_index + 1}: Found {link_count} links in {seconds_taken:.4f} seconds")

        return link_count, seconds_taken

    def mousePressEvent(self, event):
        """Handle mouse press events"""
        if event.button() == Qt.MouseButton.LeftButton and self.layout_manager:
            # Determine which page was clicked and document coordinates
            page_index = self.get_page_at_canvas_position(event.position().x(), event.position().y())

            if page_index is not None:
                doc_x, doc_y = self.canvas_to_document_coordinates(
                    page_index, event.position().x(), event.position().y()
                )

                # Emit signal with page and document coordinates
                self.mousePositionChanged.emit(page_index, doc_x, doc_y)
                print(f"üñ±Ô∏è Clicked on page {page_index + 1} at document coords ({doc_x:.1f}, {doc_y:.1f})")

        super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        """Handle mouse move events"""
        if self.layout_manager:
            page_index = self.get_page_at_canvas_position(event.position().x(), event.position().y())
            if page_index is not None:
                doc_x, doc_y = self.canvas_to_document_coordinates(
                    page_index, event.position().x(), event.position().y()
                )
                # Could emit mouse move signal here if needed

        super().mouseMoveEvent(event)

    def _get_actual_current_page(self) -> int:
        """Get the actual current page from scroll position"""
        try:
            # Try to get scroll position from parent scroll area
            parent = self.parent()
            while parent:
                if hasattr(parent, 'verticalScrollBar'):
                    scroll_y = parent.verticalScrollBar().value()
                    viewport_height = parent.viewport().height() if hasattr(parent, 'viewport') else 400

                    # Calculate page at center of viewport
                    center_y = scroll_y + (viewport_height / 2)
                    actual_page = self.get_page_at_position(center_y)

                    print(f"üìç Actual current page: scroll_y={scroll_y}, center_y={center_y}, page={actual_page}")
                    return actual_page
                parent = parent.parent()

            # Fallback to stored current_page
            return max(0, self.current_page)

        except Exception as e:
            print(f"‚ö†Ô∏è Error getting actual current page: {e}")
            return max(0, self.current_page)

    def set_visible_pages_optimized(self, page_indices: List[int], viewport_rect: QRectF):
        """
        REPLACE your existing set_visible_pages method with this optimized version
        """
        if self.is_painting:
            print("‚è∏Ô∏è Skipping page update - currently painting")
            return

        # Use smart optimizer instead of direct update
        self.smart_scroll_optimizer.update_visible_pages_optimized(page_indices, viewport_rect)

        # Update current page tracking
        if page_indices and self.current_page not in page_indices:
            new_page = page_indices[0]
            if new_page != self.current_page:
                self.current_page = new_page
                self.pageChanged.emit(new_page)

    def _smart_repaint_pages(self, pages_to_repaint: Set[int], pages_to_skip: Set[int]):
        """
        NEW METHOD: Smart repaint that only renders what's needed
        """
        print(f"üé® Smart repaint starting...")
        print(f"   Will repaint: {pages_to_repaint}")
        print(f"   Will reuse cache: {pages_to_skip}")

        # Mark which pages need new rendering
        self._pages_needing_repaint = pages_to_repaint.copy()

        # Schedule render for new pages only
        if pages_to_repaint:
            self._smart_schedule_render(pages_to_repaint)

        # Always trigger a paint event (but most pages will use cache)
        self.update()

    def _smart_schedule_render(self, pages_to_render: Set[int]):
        """
        NEW METHOD: Schedule rendering only for specific pages
        """
        print(f"‚è∞ Smart scheduling render for pages: {pages_to_render}")

        # Check which pages actually need rendering (not already cached)
        pages_needing_render = []
        for page_idx in pages_to_render:
            if page_idx not in self.rendered_pages:
                pages_needing_render.append(page_idx)

        if pages_needing_render:
            print(f"üñºÔ∏è Will render new pages: {pages_needing_render}")
            # Store what needs rendering
            self._pages_to_render = set(pages_needing_render)

            # Schedule the render
            self.needs_render = True
            self.render_timer.stop()
            self.render_timer.start(50)  # Slightly longer delay for smoother scrolling
        else:
            print(f"‚úÖ All pages already cached - no rendering needed!")

    def _perform_render_smart(self):
        """
        REPLACE your existing _perform_render method with this optimized version
        """
        if self.is_painting:
            print("‚è∏Ô∏è Skipping render - currently painting")
            return

        if not self.needs_render or not self.document or not self.layout_manager:
            print("‚ùå Smart render cancelled - missing components or not needed")
            return

        self.needs_render = False

        # Only render pages that actually need it
        pages_to_render = getattr(self, '_pages_to_render', set(self.visible_pages))

        print(f"üé® Smart rendering pages: {pages_to_render}")

        rendered_count = 0
        for page_index in pages_to_render:
            if page_index not in self.rendered_pages:
                print(f"üñºÔ∏è Rendering page {page_index}...")
                self._render_page(page_index)
                rendered_count += 1

        # Cache cleanup - keep visible + adjacent pages
        self._smart_cache_cleanup()

        print(f"üé® Smart render complete. Rendered {rendered_count} new pages.")

        # Clear the render list
        self._pages_to_render = set()

    def _smart_cache_cleanup(self):
        """
        NEW METHOD: Intelligent cache cleanup that keeps recently used pages
        """
        if not hasattr(self, 'rendered_pages'):
            return

        # Keep visible pages + 2 adjacent on each side
        pages_to_keep = set(self.visible_pages)
        for page_idx in self.visible_pages:
            pages_to_keep.add(max(0, page_idx - 1))
            pages_to_keep.add(max(0, page_idx - 2))
            if self.document:
                max_page = self.document.get_page_count() - 1
                pages_to_keep.add(min(max_page, page_idx + 1))
                pages_to_keep.add(min(max_page, page_idx + 2))

        # Remove pages not in keep list
        pages_to_remove = [p for p in self.rendered_pages.keys() if p not in pages_to_keep]
        for page_idx in pages_to_remove:
            del self.rendered_pages[page_idx]

        if pages_to_remove:
            print(f"üßπ Cache cleanup: Removed {len(pages_to_remove)} pages, kept {len(self.rendered_pages)}")


    def _paint_page_smart(self, painter, page_index: int) -> bool:
        """
        NEW METHOD: Paint page with smart caching awareness
        """
        page_rect = self.layout_manager.get_page_rect(page_index)
        if not page_rect:
            return False

        # Draw page background and border
        painter.fillRect(page_rect, QBrush(Qt.GlobalColor.white))
        painter.setPen(QPen(Qt.GlobalColor.black, 1))
        painter.drawRect(page_rect)

        # Check if we have cached content
        if page_index in self.rendered_pages:
            # Use cached pixmap
            pixmap = self.rendered_pages[page_index]
            painter.drawPixmap(page_rect.toRect(), pixmap)

            # Add overlay if needed
            if hasattr(self, '_draw_page_info_overlay'):
                self._draw_page_info_overlay(painter, page_index, page_rect)

            return True  # Painted from cache
        else:
            # Show loading indicator
            painter.setPen(QPen(Qt.GlobalColor.gray))
            painter.drawText(page_rect, Qt.AlignmentFlag.AlignCenter, f"Loading page {page_index + 1}...")
            return False  # Not from cache